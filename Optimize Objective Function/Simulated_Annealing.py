# -*- coding: utf-8 -*-
"""Objective_Function_Solvers.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IyzwASmvlNJGGuoyWWRO9gjjsjOH8Sq-

# Objective function : 2ab+2bc+2ac-a-b-c+1
find value for a,b,c

 ##### a = 0, b = 1, c = 0, objective value = 0 
 ##### a = 1, b = 0, c = 0, objective value = 0 
 ##### a = 0, b = 0, c = 1, objective value = 0
 ##### a = 1, b = 1, c = 0, objective value = 1
 ##### a = 1, b = 0, c = 1, objective value = 1
 ##### a = 0, b = 1, c = 1, objective value = 1
 ##### a = 2, b = 0, c = 0, objective value = -2
 ##### a = 0, b = 2, c = 0, objective value = -2
 ##### a = 0, b = 0, c = 2, objective value = -2
 ##### a = 1, b = 1, c = 1, objective value = 3
 ##### This notebook has solved the objective function using 4 solvers.


1.   Simulated Annealing Solver
2.   Classical Solver
3.   Hybrid Solver
4.   Quantum Solver

# Installation's Required
"""

pip install dwave-neal

pip install dimod

pip install dwave-neal

pip install dwave.system

"""# Method 1: Simulated Annealing"""

# Import the neal package for simulated annealing solver
import neal

# Define the QUBO problem as a dictionary
# Here, we're defining the problem:
# Minimize 2*a*b + 2*a*c + 2*b*c - a - b - c
# where 0 corresponds to variable a, 1 to variable b, and 2 to variable c
Q = {(0, 1): 2, (0, 2): 2, (1, 2): 2, (0, 0): -1, (1, 1): -1, (2, 2): -1}

# Define an offset for the problem. This is used to shift the energy levels
# of the problem so that the lowest energy level is greater than or equal to zero.
offset = 1

# Instantiate a simulated annealing solver
sampler = neal.SimulatedAnnealingSampler()

# Run the solver on the QUBO problem and retrieve the response
# The num_reads parameter specifies the number of times to run the solver
response = sampler.sample_qubo(Q, num_reads=5000)

# Extract the best solution and energy from the response
best_solution = response.first.sample
best_energy = response.first.energy

# Print the best solution and energy
print("Best sample:", best_solution)
print("Best energy:", best_energy + offset)

"""
# Method 2: Classical Solver"""

from dimod import ExactSolver

# showOutput function will work for showing the solution recieved from solver for objective function
def showOutput(bestSample, bestEnergy):
    print("Best sample: ", bestSample )
    print("Best energy: ", bestEnergy )

# bestSolutionExtract is for extracting best_sample and best_enery
def bestSolutionExtract(response, offset):
    bestSample = response.first.sample
    bestEnergy = response.first.energy + offset
    showOutput(bestSample, bestEnergy)

# Define the QUBO matrix
Q = {(0, 1): 2, (0, 2): 2, (1, 2): 2, (0, 0): -1, (1, 1): -1, (2, 2): -1}
offset = 1
# Initialize the ExactSolver with a classical solver
exact_solver = ExactSolver()
response = exact_solver.sample_qubo(Q)

bestSolutionExtract(response, offset)

"""## Method 3: Hybrid Solver"""

pip install pyqubo



from dwave.system import  LeapHybridSampler

# showOutput function will work for showing the solution recieved from solver for objective function
def showOutput(bestSample, bestEnergy):
    print("Best sample: ", bestSample )
    print("Best energy: ", bestEnergy )

# bestSolutionExtract is for extracting best_sample and best_enery
def bestSolutionExtract(response, offset):
    bestSample = response.first.sample
    bestEnergy = response.first.energy + offset
    showOutput(bestSample, bestEnergy)

# Defined the objective function as (QUBO) problem
# variables we have with objective function are a,b,c 
Q = {(0, 1): 2, (0, 2): 2, (1, 2): 2, (0, 0): -1, (1, 1): -1, (2, 2): -1}
offset = 1

# LeapHybridSampler requires token while running it on collab notebook. It works fine on leap IDE without token
sampler = LeapHybridSampler(token="DEV-3b2e03d4c63ab2eadcc184747e689e0fa7f63ad7") 
response = sampler.sample_qubo(Q)
bestSolutionExtract(response, offset)

"""## Method 4: Quantum Solver"""

from dwave.system.samplers import DWaveSampler 
from dwave.system.composites import EmbeddingComposite  

# showOutput function will work for showing the solution received from the solver for the objective function
def showOutput(bestSample, bestEnergy):
    print("Best sample: ", bestSample )
    print("Best energy: ", bestEnergy )

# bestSolutionExtract is for extracting the best_sample and best_energy from the response obtained from the solver
def bestSolutionExtract(response, offset):
    bestSample = response.first.sample
    bestEnergy = response.first.energy + offset
    showOutput(bestSample, bestEnergy)

# Define the objective function as a QUBO problem
# Variables we have with the objective function are a, b, c
Q = {(0, 1): 2, (0, 2): 2, (1, 2): 2, (0, 0): -1, (1, 1): -1, (2, 2): -1}
offset = 1

# Initialize the DWaveSampler
sampler = EmbeddingComposite(DWaveSampler(token="DEV-3b2e03d4c63ab2eadcc184747e689e0fa7f63ad7"))

# Sample the QUBO matrix with 1000 reads
response = sampler.sample_qubo(Q, num_reads=1000)

# Extract the best solution from the response obtained from the solver
bestSolutionExtract(response, offset)
